from .utilities import prRed, prGreen, prPurple, prWhite, prOrange, \
                        wrapRed, wrapGreen, wrapPurple, wrapWhite, wrapOrange

    


def grp_node_reroute_common(mantis_node, to_mantis_node, all_mantis_nodes):
    # we need to do this: go  to the to-node
    # then reroute the link in the to_node all the way to the beginning
    # so that the number of links in "real" nodes is unchanged
    # then the links in the dummy nodes need to be deleted
    for inp_name, inp in mantis_node.inputs.items():
        # assume each input socket only has one input for now
        if inp.is_connected:
            while (inp.links):
                in_link = inp.links.pop()
                from_mantis_node = in_link.from_node
                from_socket = in_link.from_socket
                links = []
                from_links = from_mantis_node.outputs[from_socket].links.copy()
                while(from_links):
                    from_link = from_links.pop()
                    if from_link == in_link:
                        from_link.die()
                        continue # DELETE the dummy node link 
                    links.append(from_link)
                from_mantis_node.outputs[from_socket].links = links
                down = to_mantis_node.outputs[inp_name]
                for downlink in down.links:
                    downlink.from_node = from_mantis_node
                    downlink.from_socket = from_socket
                    from_mantis_node.outputs[from_socket].links.append(downlink)
                    if hasattr(downlink.to_node, "reroute_links"):
                        downlink.to_node.reroute_links(downlink.to_node, all_mantis_nodes)
                in_link.die()

def reroute_links_grp(mantis_node, all_mantis_nodes):
    if mantis_node.inputs:
        if (to_mantis_node := all_mantis_nodes.get( ( *mantis_node.signature, "NodeGroupInput") )):
            grp_node_reroute_common(mantis_node, to_mantis_node, all_mantis_nodes)
        else:
            raise RuntimeError("internal error: failed to enter a node group ")

def reroute_links_grpout(mantis_node, all_mantis_nodes):
    if (to_mantis_node := all_mantis_nodes.get( ( *mantis_node.signature[:-1],) )):
        grp_node_reroute_common(mantis_node, to_mantis_node, all_mantis_nodes)
    else:
        raise RuntimeError("error leaving a node group (maybe you are running the tree from inside a node group?)")

# FIXME I don't think these signatures are unique.
def insert_lazy_parents(mantis_node):
    from .link_nodes import LinkInherit
    from .base_definitions import NodeLink
    inherit_mantis_node = None
    if mantis_node.inputs["Relationship"].is_connected:
        link = mantis_node.inputs["Relationship"].links[0]
        # print(mantis_node)
        from_mantis_node = link.from_node
        if from_mantis_node.node_type in ["XFORM"] and link.from_socket in ["xForm Out"]:
            inherit_mantis_node = LinkInherit(("MANTIS_AUTOGENERATED", *mantis_node.signature[1:], "LAZY_INHERIT"), mantis_node.base_tree)
            for from_link in from_mantis_node.outputs["xForm Out"].links:
                if from_link.to_node == mantis_node and from_link.to_socket == "Relationship":
                    break # this is it
            from_link.to_node = inherit_mantis_node; from_link.to_socket="Parent"
            from_link.to_node.inputs[from_link.to_socket].is_linked=True
            
            links=[]
            while (mantis_node.inputs["Relationship"].links):
                to_link = mantis_node.inputs["Relationship"].links.pop()
                if to_link.from_node == from_mantis_node and to_link.from_socket == "xForm Out":
                    continue # don't keep this one
                links.append(to_link)
                to_link.from_node.outputs[from_link.from_socket].is_linked=True
            
            mantis_node.inputs["Relationship"].links=links
            link=NodeLink(from_node=inherit_mantis_node, from_socket="Inheritance", to_node=mantis_node, to_socket="Relationship")
            inherit_mantis_node.inputs["Parent"].links.append(from_link)
            
            inherit_mantis_node.parameters = {
                                     "Parent":None,
                                     "Inherit Rotation":True,
                                     "Inherit Scale":'FULL',
                                     "Connected":False,
                                    }
            # because the from node may have already been done.
            init_connections(from_mantis_node)
            init_dependencies(from_mantis_node)
            init_connections(inherit_mantis_node)
            init_dependencies(inherit_mantis_node)
    return inherit_mantis_node

# *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** #
#                                  DATA FROM NODES                                  #
# *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** #

from .base_definitions import replace_types, NodeSocket

def autogen_node(base_tree, ui_socket, signature, mContext):
    mantis_node=None
    from .utilities import  gen_mantis_node_input_for_data
    # mantis_class = gen_mantis_node_input_for_data(ui_socket)
    # if (mantis_class):
    from .internal_nodes import AutoGenNode
    mantis_node = AutoGenNode(signature, base_tree)
    mantis_node.mContext = mContext
    mantis_node.outputs.init_sockets([ui_socket.name])
    mantis_node.ui_signature = None # does not exist in the UI
    return mantis_node

# TODO: investigate whether I can set the properties in the downstream nodes directly.
#       I am doing this in Schema Solver and it seems to work quite efficiently.
def make_connections_to_ng_dummy(base_tree, tree_path_names, local_mantis_nodes, all_mantis_nodes, to_mantis_node):
    from .socket_definitions import no_default_value
    for inp in to_mantis_node.ui_node.inputs:
        if inp.bl_idname in no_default_value:
            continue
        from_mantis_node = None
        to_s = inp.identifier
        if not inp.is_linked: # make an autogenerated NC for the inputs of the group node
            # This can be run inside schema. Make it unique with uuid() to be safe.
            from uuid import uuid4
            signature = ("MANTIS_AUTOGENERATED", *tree_path_names, to_mantis_node.ui_signature[-1], inp.name, inp.identifier, str(uuid4()))
            from_mantis_node = all_mantis_nodes.get(signature) # creating this without checking and
            #  using UUID signature leads to TERRIBLE CONFUSING BUGS.
            if from_mantis_node is None: 
                from_mantis_node = autogen_node(base_tree, inp, signature, to_mantis_node.mContext)
            from .node_common import get_socket_value
            if from_mantis_node: # autogen can fail and we should catch it.
                from_mantis_node.parameters = {inp.name:get_socket_value(inp)}
                local_mantis_nodes[signature] = from_mantis_node; all_mantis_nodes[signature] = from_mantis_node
                from_mantis_node.outputs[inp.name].connect(node=to_mantis_node, socket=to_s, sort_id=0)
            else:
                prRed("No available auto-generated class for input %s in %s" % (inp.name, np.name))

def gen_mantis_nodes(base_tree, current_tree, tree_path_names, all_mantis_nodes, local_mantis_nodes, dummy_nodes, group_nodes, schema_nodes ):
    from .internal_nodes import DummyNode
    for ui_node in current_tree.nodes:
        # HACK I found that this isn't being set sometimes. I wonder why? It makes the most sense to do this here.
        if hasattr(ui_node, 'initialized'): ui_node.initialized=True
        # end HACK. TODO: find out why this is not set sometimes. This is only needed for UI socket change updates.
        if ui_node.bl_idname in ["NodeFrame", "NodeReroute"]:
            continue # not a Mantis Node
        if ui_node.bl_idname in ["NodeGroupInput", "NodeGroupOutput"]:
            # we only want ONE dummy in/out per tree_path, so use the bl_idname to make a Dummy node
            sig = (None, *tree_path_names, ui_node.bl_idname)
            ui_sig = (None, *tree_path_names, ui_node.name)
            if not local_mantis_nodes.get(sig):
                mantis_node = DummyNode( signature=sig , base_tree=base_tree, ui_node=ui_node, ui_signature=ui_sig )
                local_mantis_nodes[sig] = mantis_node; all_mantis_nodes[sig] = mantis_node; dummy_nodes[sig] = mantis_node
                if ui_node.bl_idname in ["NodeGroupOutput"]:
                    mantis_node.reroute_links = reroute_links_grpout
        elif ui_node.bl_idname in  ["MantisNodeGroup", "MantisSchemaGroup"]:
            mantis_node = DummyNode( signature= (sig := (None, *tree_path_names, ui_node.name) ), base_tree=base_tree, ui_node=ui_node )
            local_mantis_nodes[sig] = mantis_node; all_mantis_nodes[sig] = mantis_node; dummy_nodes[sig] = mantis_node
            make_connections_to_ng_dummy(base_tree, tree_path_names, local_mantis_nodes, all_mantis_nodes, mantis_node)
            if ui_node.bl_idname == "MantisNodeGroup":
                group_nodes.append(mantis_node)
                mantis_node.reroute_links = reroute_links_grp
            else:
                group_nodes.append(mantis_node)
                schema_nodes[sig] = mantis_node
        # if it wasn't the types we ignore or the types we make a Dummy for, use this to catch all non-special cases.
        elif (mantis_class := ui_node.mantis_class):
            sig = (None, *tree_path_names, ui_node.name)
            if ui_node.bl_idname in replace_types:
                sig = (None, *tree_path_names, ui_node.bl_idname)
                if local_mantis_nodes.get(sig):
                    continue # already made
            mantis_node = mantis_class( sig , base_tree)
            local_mantis_nodes[sig] = mantis_node; all_mantis_nodes[sig] = mantis_node
            mantis_node.ui_signature = (*mantis_node.ui_signature[:-1], ui_node.name) # just to ensure it points to a real node.
        else:
            mantis_node = None
            prRed(f"Can't make mantis_node for.. {ui_node.bl_idname}")
        # this should be done at init
        if mantis_node.signature[0] not in ['MANTIS_AUTOGENERATED'] and mantis_node.node_type not in ['SCHEMA', 'DUMMY', 'DUMMY_SCHEMA']:
            mantis_node.fill_parameters()

def data_from_tree(base_tree, tree_path, dummy_nodes, all_mantis_nodes, all_schema):#
    # TODO: it should be relatively easy to make this use a while loop instead of recursion.
    local_mantis_nodes, group_nodes = {}, []
    tree_path_names = [tree.name for tree in tree_path if hasattr(tree, "name")]
    if tree_path[-1]:
        current_tree = tree_path[-1].node_tree # this may be None.
    else:
        current_tree = base_tree
    #
    if current_tree: # the node-group may not have a tree set - if so, ignore it.
        from .utilities import clear_reroutes
        links = clear_reroutes(list(current_tree.links))
        gen_mantis_nodes(base_tree, current_tree, tree_path_names, all_mantis_nodes, local_mantis_nodes, dummy_nodes, group_nodes, all_schema)
        
        from .utilities import link_mantis_nodes
        for link in links:
            link_mantis_nodes((None, *tree_path_names), link, local_mantis_nodes)
        # Now, descend into the Node Groups and recurse
        for mantis_node in group_nodes:
            data_from_tree(base_tree, tree_path+[mantis_node.ui_node], dummy_nodes, all_mantis_nodes, all_schema)
    return dummy_nodes, all_mantis_nodes, all_schema

from .utilities import check_and_add_root, init_connections, init_dependencies, init_schema_dependencies

def is_signature_in_other_signature(parent_signature, child_signature):
    # If the other signature is shorter, it isn't a child node
    if len(parent_signature) > len(child_signature):
        return False
    return parent_signature[0:] == child_signature[:len(parent_signature)]

def solve_schema_to_tree(mantis_node, all_mantis_nodes, roots=[], error_popups=False):
    from .utilities import get_ui_node
    np = get_ui_node(mantis_node.signature, mantis_node.base_tree)
    from .schema_solve import SchemaSolver
    solver = SchemaSolver(mantis_node, all_mantis_nodes.copy(), np, error_popups=error_popups)
    try:
        solved_nodes = solver.solve()
    except Exception as e:
    #     # the schema will run the error cleanup code, we just need to raise or not
        solved_nodes = {}
        mantis_node.base_tree.hash=''
        raise execution_error_cleanup(mantis_node, e, show_error=error_popups)

    # maybe this should be done in schema solver. TODO invesitigate a more efficient way
    del_me = []
    for k, v in all_mantis_nodes.items():
        # delete all the schema's ui_node and interface nodes. The links have already been deleted by the solver.
        if v.signature[0] not in ['MANTIS_AUTOGENERATED'] and is_signature_in_other_signature(mantis_node.signature, k):
            del_me.append(k)
    for k in del_me:
        del all_mantis_nodes[k]
    for k,v in solved_nodes.items():
        all_mantis_nodes[k]=v
        init_connections(v)
        check_and_add_root(v, roots, include_non_hierarchy=True)

    return solved_nodes

# *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** #
#                                  PARSE NODE TREE                                  #
# *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** #

schema_bl_idnames = [   "SchemaIndex",
                        "SchemaArrayInput",
                        "SchemaArrayInputGet",
                        "SchemaArrayInputAll",
                        "SchemaArrayOutput",
                        "SchemaConstInput",
                        "SchemaConstOutput",
                        "SchemaOutgoingConnection",
                        "SchemaIncomingConnection", 
                    ]

from .utilities import get_all_dependencies
def get_schema_length_dependencies(node, all_nodes={}):
    """ Get a list of all dependencies for the given node's length or array properties.
        This function will also recursively search for dependencies in its sub-trees.
    """
    deps = []
    prepare_links_to = ['Schema Length', 'Array', 'Index']
    def extend_dependencies_from_inputs(node):
        for inp in node.inputs.values():
            for l in inp.links:
                if not l.from_node in node.hierarchy_dependencies:
                    continue
                if "MANTIS_AUTOGENERATED" in l.from_node.signature: 
                    deps.extend([l.from_node]) # why we need this lol
                if inp.name in prepare_links_to:
                    deps.append(l.from_node)
                    deps.extend(get_all_dependencies(l.from_node))
    def deps_filter(dep): # remove any nodes inside the schema
        if len(dep.signature) > len(node.signature):
            for i in range(len(node.signature)):
                dep_sig_elem, node_sig_elem = dep.signature[i], node.signature[i]
                if dep_sig_elem != node_sig_elem: break # they don't match, it isn't an inner-node
            else: # remove this, it didn't break, meaning it shares signature with outer node
                return False # this is an inner-node
        return True
    # this way we can handle Schema and Array Get nodes with one function
    extend_dependencies_from_inputs(node)
    if node.node_type == 'DUMMY_SCHEMA':
        trees = [(node.ui_node.node_tree, node.signature)] # this is UI data
        while trees:
            tree, tree_signature = trees.pop()
            for sub_ui_node in tree.nodes:
                if sub_ui_node.bl_idname in ['NodeReroute', 'NodeFrame']:
                    continue
                if sub_ui_node.bl_idname in schema_bl_idnames:
                    sub_node = all_nodes[(*tree_signature, sub_ui_node.bl_idname)]
                else:
                    sub_node = all_nodes[(*tree_signature, sub_ui_node.name)]
                if sub_node.node_type == 'DUMMY_SCHEMA':
                    extend_dependencies_from_inputs(sub_node)
                    trees.append((sub_node.ui_node.node_tree, sub_node.signature))
    return list(filter(deps_filter, deps))


def parse_tree(base_tree, error_popups=False):
    from uuid import uuid4
    base_tree.execution_id = uuid4().__str__() # set the unique id of this execution
    
    from .base_definitions import MantisExecutionContext
    mContext = MantisExecutionContext(base_tree=base_tree)

    import time
    data_start_time = time.time()
    # annoyingly I have to pass in values for all of the dicts because if I initialize them in the function call
    #  then they stick around because the function definition inits them once and keeps a reference
    # so instead I have to supply them to avoid ugly code or bugs elsewhere
    # it's REALLY confusing when you run into this sort of problem. So it warrants four entire lines of comments!      
    dummy_nodes, all_mantis_nodes, all_schema =  data_from_tree(base_tree, tree_path = [None], dummy_nodes = {}, all_mantis_nodes = {}, all_schema={})
    for dummy in dummy_nodes.values():    # reroute the links in the group nodes
        if (hasattr(dummy, "reroute_links")):
            dummy.reroute_links(dummy, all_mantis_nodes)
    prGreen(f"Pulling data from tree took {time.time() - data_start_time} seconds")
    
    start_time = time.time()
    solve_only_these = []; solve_only_these.extend(list(all_schema.values()))
    roots, array_nodes = [], []
    from collections import deque
    unsolved_schema = deque()

    from .base_definitions import array_output_types, GraphError
    for mantis_node in all_mantis_nodes.values():
        # add the Mantis Context here, so that it available during parsing.
        mantis_node.mContext = mContext
        if mantis_node.node_type in ["DUMMY"]: # clean up the groups
            if mantis_node.ui_node.bl_idname in ("MantisNodeGroup", "NodeGroupOutput"):
                continue
        # Initialize the dependencies and connections (from/to links) for each node.
        # we record & store it because using a getter is much slower (according to profiling)
        init_dependencies(mantis_node); init_connections(mantis_node)
        check_and_add_root(mantis_node, roots, include_non_hierarchy=True)
        # Array nodes need a little special treatment, they're quasi-schemas
        if mantis_node.__class__.__name__ in array_output_types:
            solve_only_these.append(mantis_node)
            array_nodes.append(mantis_node)

    from itertools import chain
    for schema in chain(all_schema.values(), array_nodes):
        # We must remove the schema/array nodes that are inside a schema tree.
        for i in range(len(schema.signature)-1): # -1, we don't want to check this node, obviously
            if parent := all_schema.get(schema.signature[:i+1]):
                # This will be solved along with its parent schema.
                solve_only_these.remove(schema)
                break
    for schema in all_schema.values():
            if schema not in solve_only_these: continue
            init_schema_dependencies(schema, all_mantis_nodes)
            solve_only_these.extend(get_schema_length_dependencies(schema, all_mantis_nodes))
            unsolved_schema.append(schema)
    for array in array_nodes:
        if array not in solve_only_these: continue
        solve_only_these.extend(get_schema_length_dependencies(array))
    solve_only_these.extend(array_nodes)
    schema_solve_done = set()

    solve_only_these = set(solve_only_these)

    solve_layer = unsolved_schema.copy(); solve_layer.extend(roots)
    while(solve_layer):
        n = solve_layer.pop()
        if n not in solve_only_these:
            continue

        if n.signature in all_schema.keys():
            for dep in n.hierarchy_dependencies:
                if dep not in schema_solve_done and (dep in solve_only_these):
                    if dep.prepared:
                        continue 
                    solve_layer.appendleft(n)
                    break
            else:
                try:
                    solved_nodes = solve_schema_to_tree(n, all_mantis_nodes, roots, error_popups=error_popups)
                except Exception as e:
                    e = execution_error_cleanup(n, e, show_error=error_popups)
                    solved_nodes = {}
                    if error_popups == False:
                        raise e
                    return # break out of this function regardless.
                unsolved_schema.remove(n)
                schema_solve_done.add(n)
                for node in solved_nodes.values():
                    init_dependencies(node); init_connections(node)
                    solve_layer.appendleft(node)
                    schema_solve_done.add(node) # CRITICAL to prevent freezes.
                for conn in n.hierarchy_connections:
                    if conn not in schema_solve_done and conn not in solve_layer:
                        solve_layer.appendleft(conn)
            continue
        else:
            for dep in n.hierarchy_dependencies:
                if dep not in schema_solve_done:
                    break
            else:
                try:
                    n.bPrepare()
                except Exception as e:
                    e = execution_error_cleanup(n, e, show_error=error_popups)
                    if error_popups == False:
                        raise e
                    
                schema_solve_done.add(n)
                for conn in n.hierarchy_connections:
                    if conn not in schema_solve_done and conn not in solve_layer:
                        solve_layer.appendleft(conn)
                continue
    if unsolved_schema:
        raise RuntimeError("Failed to resolve all schema declarations")
    # I had a problem with this looping forever. I think it is resolved... but I don't know lol

    all_mantis_nodes = list(all_mantis_nodes.values())
    kept_mantis_node = {}
    while (all_mantis_nodes):
        mantis_node = all_mantis_nodes.pop()
        if mantis_node in array_nodes:
            continue
        if mantis_node.node_type in ["DUMMY", 'SCHEMA', 'DUMMY_SCHEMA']:
            continue # screen out the ui_node schema nodes, group in/out, and group placeholders
        # cleanup autogen nodes
        if mantis_node.signature[0] == "MANTIS_AUTOGENERATED" and len(mantis_node.inputs) == 0 and len(mantis_node.outputs) == 1:
            from .base_definitions import can_remove_socket_for_autogen
            output=list(mantis_node.outputs.values())[0]
            value=list(mantis_node.parameters.values())[0]   # IDEA modify the dependecy get function to exclude these nodes completely
            keep_me = False
            for l in output.links:
                to_node = l.to_node; to_socket = l.to_socket
                # do not remove the socket if it is a custom property.
                if not can_remove_socket_for_autogen(to_node, to_socket):
                    keep_me = True; continue
                l.die()
                to_node.parameters[to_socket] = value
                del to_node.inputs[to_socket]
                init_dependencies(to_node) # to remove the autogen node we no longer need.
            if not keep_me:
                continue
            init_connections(mantis_node) # because we have removed many connections.

        if (mantis_node.node_type in ['XFORM']) and ("Relationship" in mantis_node.inputs.keys()):
            if (new_mantis_node := insert_lazy_parents(mantis_node)):
                kept_mantis_node[new_mantis_node.signature]=new_mantis_node
                # be sure to add the Mantis context.
                new_mantis_node.mContext =mContext
        kept_mantis_node[mantis_node.signature]=mantis_node
    prWhite(f"Parsing tree took {time.time()-start_time} seconds.")
    prWhite("Number of Nodes: %s" % (len(kept_mantis_node)))
    return kept_mantis_node

from .utilities import switch_mode

def execution_error_cleanup(node, exception, switch_objects = [], show_error=False ):
    from bpy import  context
    ui_sig = None
    if show_error: # show a popup and select the relevant nodes
        if node:
            if node.mContext:
                if node.mContext.execution_failed==True:
                    # already have an error, pass it to avoid printing
                    return # a second error (it's confusing to users.)
                node.mContext.execution_failed=True
            ui_sig = node.ui_signature
            # TODO: see about zooming-to-node.
            base_tree = node.base_tree
            tree = base_tree
            try:
                pass
                space = context.space_data
                for name in ui_sig[1:]:
                    for n in tree.nodes: n.select = False
                    n = tree.nodes[name]
                    n.select = True
                    tree.nodes.active = n
                    if hasattr(n, "node_tree"):
                        tree = n.node_tree
            except AttributeError: # not being run in node graph
                pass
            finally:
                def error_popup_draw(self, context):
                    self.layout.label(text=f"Error: {exception}")
                    self.layout.label(text=f"see node: {ui_sig[1:]}.")
                context.window_manager.popup_menu(error_popup_draw, title="Error", icon='ERROR')
    switch_mode(mode='OBJECT', objects=switch_objects)
    for ob in switch_objects:
        ob.data.pose_position = 'POSE'
    prRed(f"Error: {exception} in node {ui_sig}")
    return exception

def sort_execution(nodes, xForm_pass):
    execution_failed=False
    sorted_nodes = []
    from .node_common import GraphError
    # check for cycles here by keeping track of the number of times a node has been visited.
    visited={}
    check_max_len=len(nodes)**2 # seems too high but safe. In a well-ordered graph, I guess this number should be less than the number of nodes.
    max_iterations = len(nodes)**2
    i = 0
    while(xForm_pass):
        if execution_failed: break
        if i >= max_iterations:
            execution_failed = True
            raise GraphError("There is probably a cycle somewhere in the graph. "
                                "Or a connection missing in a Group/Schema Input")
        i+=1    
        n = xForm_pass.pop()
        if visited.get(n.signature) is not None:
            visited[n.signature]+=1
        else:
            visited[n.signature]=0
        if visited[n.signature] > check_max_len:
            execution_failed = True
            raise GraphError("There is a probably a cycle in the graph somewhere. "
                                "Or a connection missing in a Group/Schema Input")
            # we're trying to solve the halting problem at this point.. don't do that.
            # TODO find a better way! there are algo's for this but they will require using a different solving algo, too
        if n.execution_prepared:
            continue
        if n.node_type not in ['XFORM', 'UTILITY']:
            for dep in n.hierarchy_dependencies:
                if not dep.execution_prepared:
                    xForm_pass.appendleft(n) # hold it
                    break
            else:
                n.execution_prepared=True
                sorted_nodes.append(n)
                for conn in n.hierarchy_connections:
                    if  not conn.execution_prepared:
                        xForm_pass.appendleft(conn)
        else:
            for dep in n.hierarchy_dependencies:
                if not dep.execution_prepared:
                    break
            else:
                n.execution_prepared=True
                sorted_nodes.append(n)
                for conn in n.hierarchy_connections:
                    if  not conn.execution_prepared:
                        xForm_pass.appendleft(conn)
    return sorted_nodes, execution_failed

def execute_tree(nodes, base_tree, context, error_popups = False):
    assert nodes is not None, "Failed to parse tree."
    assert len(nodes) > 0, "No parsed nodes for execution."\
                           " Mantis probably failed to parse the tree."
    import bpy
    from time import time
    from .node_common import GraphError
    original_active = context.view_layer.objects.active
    start_execution_time = time()
    mContext = None
    from collections import deque
    xForm_pass = deque()
    for mantis_node in nodes.values():
        if not mContext: # just grab one of these. this is a silly way to do this.
            mContext = mantis_node.mContext
            mContext.b_objects = {} # clear the objects and recreate them
        mantis_node.reset_execution()
        check_and_add_root(mantis_node, xForm_pass)
    mContext.execution_failed = False

    switch_me = [] # switch the mode on these objects
    active = None # only need it for switching modes
    select_me = []
    try:
        sorted_nodes, execution_failed = sort_execution(nodes, xForm_pass)
        for n in sorted_nodes:
            try:
                if not n.prepared:
                    n.bPrepare(context)
                if not n.executed:
                    n.bTransformPass(context)
                if (n.__class__.__name__ == "xFormArmature" ):
                    ob = n.bGetObject()
                    switch_me.append(ob)
                    active = ob
                if not (n.__class__.__name__ == "xFormBone" ) and hasattr(n, "bGetObject"):
                    ob = n.bGetObject()
                    if isinstance(ob, bpy.types.Object):
                        select_me.append(ob)
            except Exception as e:
                e = execution_error_cleanup(n, e, show_error=error_popups)
                if error_popups == False:
                    raise e
                execution_failed = True; break

        switch_mode(mode='POSE', objects=switch_me)

        for n in sorted_nodes:
            try:
                if not n.prepared:
                    n.bPrepare(context)
                if not n.executed:
                    n.bRelationshipPass(context)
            except Exception as e:
                e = execution_error_cleanup(n, e, show_error=error_popups)
                if error_popups == False:
                    raise e
                execution_failed = True; break


        switch_mode(mode='OBJECT', objects=switch_me)
        # switch to pose mode here so that the nodes can use the final pose data
        # this will require them to update the depsgraph.
        

        for ob in switch_me:
            ob.data.pose_position = 'POSE'

        for n in sorted_nodes:
            try:
                n.bFinalize(context)
            except Exception as e:
                e = execution_error_cleanup(n, e, show_error=error_popups)
                if error_popups == False:
                    raise e
                execution_failed = True; break
        
        
        # REST pose for deformer bind, so everything is in the rest position
        for ob in switch_me:
            ob.data.pose_position = 'REST'

        # finally, apply modifiers and bind stuff
        for n in sorted_nodes:
            try:
                n.bModifierApply(context)
            except Exception as e:
                e = execution_error_cleanup(n, e, show_error=error_popups)
                if error_popups == False:
                    raise e
                execution_failed = True; break
                
        for ob in switch_me:
            ob.data.pose_position = 'POSE'
        
        tot_time = (time() - start_execution_time)
        if not execution_failed:
            prGreen(f"Executed tree of {len(sorted_nodes)} nodes in {tot_time} seconds")
        if (original_active):
            context.view_layer.objects.active = original_active
            original_active.select_set(True)
    except Exception as e:
        e = execution_error_cleanup(None, e, switch_me, show_error=error_popups)
        if error_popups == False:
            raise e
        prRed(f"Failed to execute tree.")
    finally:
        context.view_layer.objects.active = active
        # clear the selection first.
        from itertools import chain
        for ob in context.selected_objects:
            try:
                ob.select_set(False)
            except RuntimeError: # it isn't in the view layer
                pass
        for ob in chain(select_me, mContext.b_objects.values()):
            try:
                ob.select_set(True)
            except RuntimeError: # it isn't in the view layer
                pass

