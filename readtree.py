from .utilities import prRed, prGreen, prPurple, prWhite, prOrange, \
                        wrapRed, wrapGreen, wrapPurple, wrapWhite, wrapOrange


# this function is kind of confusing and is very important,
# so it bears a full explanation: its purpose is to connect
# the links going into a group to the nodes in that group.
# FIRST we connect all the incoming links into the Group Node to
# a Group Interface node that does nothing but mark the entrance.
# Then, we connect all the outgoing links back to the nodes
# that had incoming links, so the nodes OUTSIDE the Node Group
# are connected directly to BOTH the GroupInterface and the
# nodes INSIDE the node group.
# we give the GroupInterface nodes an obscenely high
# multi_input_sort_id so that they are always last.
# but since these links are going IN, they shouldn't cause any problems.
# the sub_sort_id is set here in case there are UI links which represent
# multiple Mantis links - the mantis links are sorted within the UI links
# and the UI links are sorted as normal, so all the links are in the right
# order.... probably. BUG here?
# I want the Group Interface nodes to be part of the hierarchy...
# but I want to cut the links. hmmm what to do? Fix it if it causes problems.
# solution to hypothetical BUG could be to do traversal on the links
# instead of the sockets.
def grp_node_reroute_common(in_node, out_node, interface):
    from .base_definitions import links_sort_key
    for in_node_input in in_node.inputs:
        i = 0
        if len(in_node_input.links)>1: # sort here to ensure correct sub_sort_id
            in_node_input.links.sort(key=links_sort_key)
        while (in_node_input.links):
            in_link = in_node_input.links.pop()
            from_node = in_link.from_node; from_socket = in_link.from_socket
            link = from_node.outputs[from_socket].connect(
                interface,in_node_input.name, sort_id = 2**16, sub_sort_id=i)
            i += 1; in_link.die()
    for out_node_output in out_node.outputs:
        while (out_node_output.links):
            out_link = out_node_output.links.pop()
            to_node = out_link.to_node; to_socket = out_link.to_socket
            for j, l in enumerate(interface.inputs[out_node_output.name].links):
                # we are connecting the link from the ORIGINAL output to the FINAL input.
                link = l.from_node.outputs[l.from_socket].connect(
                    to_node, to_socket, sort_id = out_link.multi_input_sort_id)
                link.sub_sort_id = j
            out_link.die()

def reroute_links_grp(group, all_nodes):
    from .internal_nodes import GroupInterface
    interface = GroupInterface(
        ( *group.signature, "InputInterface"),
        group.base_tree, group.ui_node, 'INPUT',)
    all_nodes[interface.signature] = interface
    if group.inputs:
        if group_input := all_nodes.get(( *group.signature, "NodeGroupInput")):
            grp_node_reroute_common(group, group_input, interface)
        else:
            raise RuntimeError("internal error: failed to enter a node group ")

def reroute_links_grpout(group_output, all_nodes):
    if (group := all_nodes.get( ( *group_output.signature[:-1],) )):
        from .internal_nodes import GroupInterface
        interface = GroupInterface(
            ( *group.signature, "OutputInterface"),
            group.base_tree, group.ui_node, 'OUTPUT',)
        all_nodes[interface.signature] = interface
        grp_node_reroute_common(group_output, group, interface)
    else:
        prOrange(f"WARN: unconnected outputs from a node group "
                 "(maybe you are running the tree from inside a node group?)")

# FIXME I don't think these signatures are unique.
# TODO this is a really silly and bad and also really dumb way to do this
def insert_lazy_parents(mantis_node):
    from .link_nodes import LinkInherit
    inherit_node = None
    if mantis_node.inputs["Relationship"].is_connected:
        from .node_common import trace_single_line
        node_line, last_socket = trace_single_line(mantis_node, 'Relationship')
        # if last_socket is from a valid XFORM, it is the relationship in
        # because it was traversed from the xForm Out... so get the traverse target.
        if last_socket.traverse_target is None:
            return # this is not a valid lazy parent.
        for other_node in node_line[1:]: # skip the first one, it is the same node
            if other_node.node_type == 'LINK':
                return # this one has a realtionship connection.
            elif other_node.node_type == 'XFORM':
                break
        if other_node.node_type in ["XFORM"] and last_socket.traverse_target.name in ["xForm Out"]:
            for link in other_node.outputs['xForm Out'].links:
                if link.to_node == mantis_node: link.die()
            inherit_node = LinkInherit(("MANTIS_AUTOGENERATED", *mantis_node.signature[1:], "LAZY_INHERIT"), mantis_node.base_tree)
            l = other_node.outputs['xForm Out'].connect(inherit_node, 'Parent')
            l1 = inherit_node.outputs['Inheritance'].connect(mantis_node, 'Relationship')
            inherit_node.parameters = { "Parent":None,
                                      "Inherit Rotation":True,
                                      "Inherit Scale":'FULL',
                                      "Connected":False, }
            # because the from node may have already been done.
            init_connections(other_node); init_dependencies(other_node)
            init_connections(inherit_node); init_dependencies(inherit_node)
    return inherit_node

# *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** #
#                                  DATA FROM NODES                                  #
# *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** #

from .base_definitions import replace_types, NodeSocket

def autogen_node(base_tree, ui_socket, signature, mContext):
    mantis_node=None
    from .internal_nodes import AutoGenNode
    mantis_node = AutoGenNode(signature, base_tree)
    mantis_node.mContext = mContext
    mantis_node.outputs.init_sockets([ui_socket.name])
    mantis_node.ui_signature = None # does not exist in the UI
    return mantis_node

# TODO: investigate whether I can set the properties in the downstream nodes directly.
#       I am doing this in Schema Solver and it seems to work quite efficiently.
def make_connections_to_ng_dummy(base_tree, tree_path_names, local_mantis_nodes, all_mantis_nodes, to_mantis_node):
    from .socket_definitions import no_default_value
    for inp in to_mantis_node.ui_node.inputs:
        if inp.bl_idname in no_default_value:
            continue
        from_mantis_node = None
        to_s = inp.identifier
        if not inp.is_linked: # make an autogenerated NC for the inputs of the group node
            # This can be run inside schema. Make it unique with uuid() to be safe.
            from uuid import uuid4
            signature = ("MANTIS_AUTOGENERATED", *tree_path_names, to_mantis_node.ui_signature[-1], inp.name, inp.identifier, str(uuid4()))
            from_mantis_node = all_mantis_nodes.get(signature) # creating this without checking and
            #  using UUID signature leads to TERRIBLE CONFUSING BUGS.
            if from_mantis_node is None: 
                from_mantis_node = autogen_node(base_tree, inp, signature, to_mantis_node.mContext)
            from .node_common import get_socket_value
            if from_mantis_node: # autogen can fail and we should catch it.
                from_mantis_node.parameters = {inp.name:get_socket_value(inp)}
                local_mantis_nodes[signature] = from_mantis_node; all_mantis_nodes[signature] = from_mantis_node
                from_mantis_node.outputs[inp.name].connect(node=to_mantis_node, socket=to_s, sort_id=0)
            else:
                prRed("No available auto-generated class for input %s in %s" % (inp.name, np.name))

def gen_mantis_nodes(base_tree, current_tree, tree_path_names, all_mantis_nodes, local_mantis_nodes, dummy_nodes, group_nodes, schema_nodes ):
    from .internal_nodes import DummyNode
    for ui_node in current_tree.nodes:
        # HACK I found that this isn't being set sometimes. I wonder why? It makes the most sense to do this here.
        if hasattr(ui_node, 'initialized'): ui_node.initialized=True
        # end HACK. TODO: find out why this is not set sometimes. This is only needed for UI socket change updates.
        if ui_node.bl_idname in ["NodeFrame", "NodeReroute"]:
            continue # not a Mantis Node
        if ui_node.bl_idname in ["NodeGroupInput", "NodeGroupOutput"]:
            # we only want ONE dummy in/out per tree_path, so use the bl_idname to make a Dummy node
            sig = (None, *tree_path_names, ui_node.bl_idname)
            ui_sig = (None, *tree_path_names, ui_node.name)
            if not local_mantis_nodes.get(sig):
                mantis_node = DummyNode( signature=sig , base_tree=base_tree, ui_node=ui_node, ui_signature=ui_sig )
                local_mantis_nodes[sig] = mantis_node; all_mantis_nodes[sig] = mantis_node; dummy_nodes[sig] = mantis_node
                if ui_node.bl_idname in ["NodeGroupOutput"]:
                    mantis_node.reroute_links = reroute_links_grpout
        elif ui_node.bl_idname in  ["MantisNodeGroup", "MantisSchemaGroup"]:
            mantis_node = DummyNode( signature= (sig := (None, *tree_path_names, ui_node.name) ), base_tree=base_tree, ui_node=ui_node )
            local_mantis_nodes[sig] = mantis_node; all_mantis_nodes[sig] = mantis_node; dummy_nodes[sig] = mantis_node
            make_connections_to_ng_dummy(base_tree, tree_path_names, local_mantis_nodes, all_mantis_nodes, mantis_node)
            if ui_node.bl_idname == "MantisNodeGroup":
                group_nodes.append(mantis_node)
                mantis_node.reroute_links = reroute_links_grp
            else:
                group_nodes.append(mantis_node)
                schema_nodes[sig] = mantis_node
        # if it wasn't the types we ignore or the types we make a Dummy for, use this to catch all non-special cases.
        elif (mantis_class := ui_node.mantis_class):
            sig = (None, *tree_path_names, ui_node.name)
            if ui_node.bl_idname in replace_types:
                sig = (None, *tree_path_names, ui_node.bl_idname)
                if local_mantis_nodes.get(sig):
                    continue # already made
            mantis_node = mantis_class( sig , base_tree)
            local_mantis_nodes[sig] = mantis_node; all_mantis_nodes[sig] = mantis_node
            mantis_node.ui_signature = (*mantis_node.ui_signature[:-1], ui_node.name) # just to ensure it points to a real node.
        else:
            mantis_node = None
            prRed(f"Can't make mantis_node for.. {ui_node.bl_idname}")
        # this should be done at init
        if mantis_node.signature[0] not in ['MANTIS_AUTOGENERATED'] and mantis_node.node_type not in ['SCHEMA', 'DUMMY', 'DUMMY_SCHEMA']:
            mantis_node.fill_parameters()

def data_from_tree(base_tree, tree_path, dummy_nodes, all_mantis_nodes, all_schema):#
    # TODO: it should be relatively easy to make this use a while loop instead of recursion.
    local_mantis_nodes, group_nodes = {}, []
    tree_path_names = [tree.name for tree in tree_path if hasattr(tree, "name")]
    if tree_path[-1]:
        current_tree = tree_path[-1].node_tree # this may be None.
    else:
        current_tree = base_tree
    #
    if current_tree: # the node-group may not have a tree set - if so, ignore it.
        from .utilities import clear_reroutes
        links = clear_reroutes(list(current_tree.links))
        gen_mantis_nodes(base_tree, current_tree, tree_path_names, all_mantis_nodes, local_mantis_nodes, dummy_nodes, group_nodes, all_schema)

        from .utilities import link_mantis_nodes
        for link in links:
            link_mantis_nodes((None, *tree_path_names), link, local_mantis_nodes)
        if current_tree == base_tree:
            # in the base tree, we need to auto-gen the default values in a slightly different way to node groups.
            insert_default_values_base_tree(base_tree, all_mantis_nodes)
        # Now, descend into the Node Groups and recurse
        for mantis_node in group_nodes:
            data_from_tree(base_tree, tree_path+[mantis_node.ui_node], dummy_nodes, all_mantis_nodes, all_schema)
    return dummy_nodes, all_mantis_nodes, all_schema

from .utilities import check_and_add_root, init_connections, init_dependencies, init_schema_dependencies

def is_signature_in_other_signature(parent_signature, child_signature):
    # If the other signature is shorter, it isn't a child node
    if len(parent_signature) > len(child_signature):
        return False
    return parent_signature[0:] == child_signature[:len(parent_signature)]

def solve_schema_to_tree(mantis_node, all_mantis_nodes, roots=[], error_popups=False):
    from .utilities import get_ui_node
    np = get_ui_node(mantis_node.signature, mantis_node.base_tree)
    from .schema_solve import SchemaSolver
    solver = SchemaSolver(mantis_node, all_mantis_nodes.copy(), np, error_popups=error_popups)
    try:
        solved_nodes = solver.solve()
    except Exception as e:
    #     # the schema will run the error cleanup code, we just need to raise or not
        solved_nodes = {}
        mantis_node.base_tree.hash=''
        raise execution_error_cleanup(mantis_node, e, show_error=error_popups)

    # maybe this should be done in schema solver. TODO invesitigate a more efficient way
    del_me = []
    for k, v in all_mantis_nodes.items():
        # delete all the schema's ui_node and interface nodes. The links have already been deleted by the solver.
        if v.signature[0] not in ['MANTIS_AUTOGENERATED'] and is_signature_in_other_signature(mantis_node.signature, k):
            del_me.append(k)
    for k in del_me:
        del all_mantis_nodes[k]
    for k,v in solved_nodes.items():
        all_mantis_nodes[k]=v
        init_connections(v)
        check_and_add_root(v, roots, include_non_hierarchy=True)

    return solved_nodes

# *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** #
#                                  PARSE NODE TREE                                  #
# *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** # *** #

schema_bl_idnames = [   "SchemaIndex",
                        "SchemaArrayInput",
                        "SchemaArrayInputGet",
                        "SchemaArrayInputAll",
                        "SchemaArrayOutput",
                        "SchemaConstInput",
                        "SchemaConstOutput",
                        "SchemaOutgoingConnection",
                        "SchemaIncomingConnection",
                    ]

from .utilities import get_all_dependencies
def get_schema_length_dependencies(node, all_nodes={}):
    """ Get a list of all dependencies for the given node's length or array properties.
        This function will also recursively search for dependencies in its sub-trees.
    """
    deps = []
    prepare_links_to = ['Schema Length', 'Array', 'Index']
    def extend_dependencies_from_inputs(node):
        for inp in node.inputs.values():
            for l in inp.links:
                if not l.from_node in node.hierarchy_dependencies:
                    continue
                if "MANTIS_AUTOGENERATED" in l.from_node.signature:
                    deps.extend([l.from_node]) # why we need this lol
                if inp.name in prepare_links_to:
                    deps.append(l.from_node)
                    deps.extend(get_all_dependencies(l.from_node))
    def deps_filter(dep): # remove any nodes inside the schema
        if len(dep.signature) > len(node.signature):
            for i in range(len(node.signature)):
                dep_sig_elem, node_sig_elem = dep.signature[i], node.signature[i]
                if dep_sig_elem != node_sig_elem: break # they don't match, it isn't an inner-node
            else: # remove this, it didn't break, meaning it shares signature with outer node
                return False # this is an inner-node
        return True
    # this way we can handle Schema and Array Get nodes with one function
    extend_dependencies_from_inputs(node)
    if node.node_type == 'DUMMY_SCHEMA':
        trees = [(node.ui_node.node_tree, node.signature)] # this is UI data
        while trees:
            tree, tree_signature = trees.pop()
            for sub_ui_node in tree.nodes:
                if sub_ui_node.bl_idname in ['NodeReroute', 'NodeFrame']:
                    continue
                if sub_ui_node.bl_idname in schema_bl_idnames:
                    sub_node = all_nodes[(*tree_signature, sub_ui_node.bl_idname)]
                else:
                    sub_node = all_nodes[(*tree_signature, sub_ui_node.name)]
                if sub_node.node_type == 'DUMMY_SCHEMA':
                    extend_dependencies_from_inputs(sub_node)
                    trees.append((sub_node.ui_node.node_tree, sub_node.signature))
    return list(filter(deps_filter, deps))

def insert_default_values_base_tree(base_tree, all_mantis_nodes):
    # we can get this by name because group inputs are gathered to the bl_idname
    InputNode = all_mantis_nodes.get((None, 'NodeGroupInput'))
    if InputNode is None: return # nothing to do here.
    ui_node = InputNode.ui_node

    for i, output in enumerate(InputNode.outputs):
        ui_output = ui_node.outputs[i] # I need this for the error messages to make sense
        assert ui_output.identifier == output.name, "Cannot find UI Socket for Default Value"
        for interface_item in base_tree.interface.items_tree:
            if interface_item.item_type == 'PANEL': continue
            if interface_item.identifier == output.name: break
        else:
            raise RuntimeError(f"Default value {ui_output.name} does not exist in {base_tree.name} ")
        if interface_item.item_type == "PANEL":
            raise RuntimeError(f"Cannot get default value for {ui_output.name} in {base_tree.name} ")
        default_value = None
        from bpy.types import bpy_prop_array
        from mathutils import Vector
        val_type = None
        if hasattr(ui_output, 'default_value'):
            val_type = type(ui_output.default_value) # why tf can't I match/case here?
        if val_type is bool: default_value = interface_item.default_bool
        elif val_type is int: default_value = interface_item.default_int
        elif val_type is float: default_value = interface_item.default_float
        elif val_type is Vector: default_value = interface_item.default_vector
        elif val_type is str: default_value = interface_item.default_string
        elif val_type is bpy_prop_array: default_value = interface_item.default_bool_vector
        elif interface_item.bl_socket_idname == "xFormSocket":
            if interface_item.default_xForm == 'ARMATURE':
                default_value = 'MANTIS_DEFAULT_ARMATURE'
            else:
                raise RuntimeError(f"No xForm connected for {ui_output.name} in {base_tree.name}.")

        else:
            raise RuntimeError(f"Cannot get default value for {ui_output.name} in {base_tree.name} ")
        output_name = output.name
        if interface_item.bl_socket_idname not in ['xFormSocket']:
            signature = ("MANTIS_AUTOGENERATED", f"Default Value {output.name}",)
            autogen_mantis_node = all_mantis_nodes.get(signature)
            if autogen_mantis_node is None:
                autogen_mantis_node = autogen_node(base_tree, output, signature, InputNode.mContext)
                autogen_mantis_node.parameters[output_name]=default_value
        elif interface_item.bl_socket_idname == 'xFormSocket' \
                                        and default_value == 'MANTIS_DEFAULT_ARMATURE':
            signature = ("MANTIS_AUTOGENERATED", "MANTIS_DEFAULT_ARMATURE",)
            autogen_mantis_node = all_mantis_nodes.get(signature)
            if autogen_mantis_node is None:
                from .xForm_nodes import xFormArmature
                autogen_mantis_node = xFormArmature(signature, base_tree)
                autogen_mantis_node.parameters['Name']=base_tree.name+'_MANTIS_AUTOGEN'
                autogen_mantis_node.mContext =  InputNode.mContext
                from mathutils import Matrix
                autogen_mantis_node.parameters['Matrix'] = Matrix.Identity(4)
            output_name = 'xForm Out'
        while output.links:
            l = output.links.pop()
            to_node = l.to_node; to_socket = l.to_socket
            l.die()
            autogen_mantis_node.outputs[output_name].connect(to_node, to_socket)
            init_connections(l.from_node); init_dependencies(l.from_node)
        all_mantis_nodes[autogen_mantis_node.signature]=autogen_mantis_node

def parse_tree(base_tree, error_popups=False):
    from uuid import uuid4
    base_tree.execution_id = uuid4().__str__() # set the unique id of this execution

    from .base_definitions import MantisExecutionContext
    mContext = MantisExecutionContext(base_tree=base_tree)

    import time
    data_start_time = time.time()
    # annoyingly I have to pass in values for all of the dicts because if I initialize them in the function call
    #  then they stick around because the function definition inits them once and keeps a reference
    # so instead I have to supply them to avoid ugly code or bugs elsewhere
    # it's REALLY confusing when you run into this sort of problem. So it warrants four entire lines of comments!      
    dummy_nodes, all_mantis_nodes, all_schema =  data_from_tree(base_tree, tree_path = [None], dummy_nodes = {}, all_mantis_nodes = {}, all_schema={})
    for dummy in dummy_nodes.values():    # reroute the links in the group nodes
        if (hasattr(dummy, "reroute_links")):
            dummy.reroute_links(dummy, all_mantis_nodes)
    prGreen(f"Pulling data from tree took {time.time() - data_start_time} seconds")

    start_time = time.time()
    solve_only_these = []; solve_only_these.extend(list(all_schema.values()))
    roots, array_nodes = [], []
    from collections import deque
    unsolved_schema = deque()

    from .base_definitions import array_output_types, GraphError
    for mantis_node in all_mantis_nodes.values():
        # add the Mantis Context here, so that it available during parsing.
        mantis_node.mContext = mContext
        if mantis_node.node_type in ["DUMMY"]: # clean up the groups
            if mantis_node.ui_node.bl_idname in ("MantisNodeGroup", "NodeGroupOutput"):
                continue
        # Initialize the dependencies and connections (from/to links) for each node.
        # we record & store it because using a getter is much slower (according to profiling)
        init_dependencies(mantis_node); init_connections(mantis_node)
        check_and_add_root(mantis_node, roots, include_non_hierarchy=True)
        # Array nodes need a little special treatment, they're quasi-schemas
        if mantis_node.__class__.__name__ in array_output_types:
            solve_only_these.append(mantis_node)
            array_nodes.append(mantis_node)

    from itertools import chain
    for schema in chain(all_schema.values(), array_nodes):
        # We must remove the schema/array nodes that are inside a schema tree.
        for i in range(len(schema.signature)-1): # -1, we don't want to check this node, obviously
            if parent := all_schema.get(schema.signature[:i+1]):
                # This will be solved along with its parent schema.
                solve_only_these.remove(schema)
                break
    for schema in all_schema.values():
            if schema not in solve_only_these: continue
            init_schema_dependencies(schema, all_mantis_nodes)
            solve_only_these.extend(get_schema_length_dependencies(schema, all_mantis_nodes))
            unsolved_schema.append(schema)
    for array in array_nodes:
        if array not in solve_only_these: continue
        solve_only_these.extend(get_schema_length_dependencies(array))
    solve_only_these.extend(array_nodes)
    schema_solve_done = set()

    solve_only_these = set(solve_only_these)

    solve_layer = unsolved_schema.copy(); solve_layer.extend(roots)
    while(solve_layer):
        n = solve_layer.pop()
        if n not in solve_only_these:
            continue

        if n.signature in all_schema.keys():
            for dep in n.hierarchy_dependencies:
                if dep not in schema_solve_done and (dep in solve_only_these):
                    if dep.prepared:
                        continue
                    solve_layer.appendleft(n)
                    break
            else:
                try:
                    solved_nodes = solve_schema_to_tree(n, all_mantis_nodes, roots, error_popups=error_popups)
                except Exception as e:
                    e = execution_error_cleanup(n, e, show_error=error_popups)
                    solved_nodes = {}
                    if error_popups == False:
                        raise e
                    return # break out of this function regardless.
                unsolved_schema.remove(n)
                schema_solve_done.add(n)
                for node in solved_nodes.values():
                    init_dependencies(node); init_connections(node)
                    solve_layer.appendleft(node)
                    schema_solve_done.add(node) # CRITICAL to prevent freezes.
                for conn in n.hierarchy_connections:
                    if conn not in schema_solve_done and conn not in solve_layer:
                        solve_layer.appendleft(conn)
            continue
        else:
            for dep in n.hierarchy_dependencies:
                if dep not in schema_solve_done:
                    break
            else:
                try:
                    n.bPrepare()
                except Exception as e:
                    e = execution_error_cleanup(n, e, show_error=error_popups)
                    if error_popups == False:
                        raise e
                schema_solve_done.add(n)
                for conn in n.hierarchy_connections:
                    if conn not in schema_solve_done and conn not in solve_layer:
                        solve_layer.appendleft(conn)
                continue
    if unsolved_schema:
        raise RuntimeError("Failed to resolve all schema declarations")
    # I had a problem with this looping forever. I think it is resolved... but I don't know lol

    all_mantis_nodes = list(all_mantis_nodes.values())
    kept_mantis_node = {}
    while (all_mantis_nodes):
        mantis_node = all_mantis_nodes.pop()
        if mantis_node in array_nodes:
            continue
        if mantis_node.node_type in ["DUMMY", 'SCHEMA', 'DUMMY_SCHEMA']:
            continue # screen out the ui_node schema nodes, group in/out, and group placeholders
        # cleanup autogen nodes
        if mantis_node.signature[0] == "MANTIS_AUTOGENERATED" and len(mantis_node.inputs) == 0 and len(mantis_node.outputs) == 1:
            from .base_definitions import can_remove_socket_for_autogen
            output=list(mantis_node.outputs.values())[0]
            value=list(mantis_node.parameters.values())[0]
            # We can remove this node if it is safe to push it into the other node's socket.
            keep_me = False
            for l in output.links:
                to_node = l.to_node; to_socket = l.to_socket
                # do not remove the socket if it is a custom property.
                if not can_remove_socket_for_autogen(to_node, to_socket):
                    keep_me = True; continue
                l.die()
                to_node.parameters[to_socket] = value
                del to_node.inputs[to_socket]
                init_dependencies(to_node) # to remove the autogen node we no longer need.
            if not keep_me:
                continue
            init_connections(mantis_node) # because we have removed many connections.

        if (mantis_node.node_type in ['XFORM']) and ("Relationship" in mantis_node.inputs.keys()):
            if (new_mantis_node := insert_lazy_parents(mantis_node)):
                kept_mantis_node[new_mantis_node.signature]=new_mantis_node
                # be sure to add the Mantis context.
                new_mantis_node.mContext =mContext
        kept_mantis_node[mantis_node.signature]=mantis_node
    prWhite(f"Parsing tree took {time.time()-start_time} seconds.")
    prWhite("Number of Nodes: %s" % (len(kept_mantis_node)))
    return kept_mantis_node

from .utilities import switch_mode

def execution_error_cleanup(node, exception, switch_objects = [], show_error=False ):
    from bpy import  context
    ui_sig = None
    if show_error: # show a popup and select the relevant nodes
        if node:
            if node.mContext:
                if node.mContext.execution_failed==True:
                    # already have an error, pass it to avoid printing
                    return # a second error (it's confusing to users.)
                node.mContext.execution_failed=True
            ui_sig = node.ui_signature
            # TODO: see about zooming-to-node.
            base_tree = node.base_tree
            tree = base_tree
            try:
                pass
                space = context.space_data
                for name in ui_sig[1:]:
                    for n in tree.nodes: n.select = False
                    n = tree.nodes[name]
                    n.select = True
                    tree.nodes.active = n
                    if hasattr(n, "node_tree"):
                        tree = n.node_tree
            except AttributeError: # not being run in node graph
                pass
            finally:
                def error_popup_draw(self, context):
                    self.layout.label(text=f"Error: {exception}")
                    self.layout.label(text=f"see node: {ui_sig[1:]}.")
                context.window_manager.popup_menu(error_popup_draw, title="Error", icon='ERROR')
    switch_mode(mode='OBJECT', objects=switch_objects)
    for ob in switch_objects:
        ob.data.pose_position = 'POSE'
    prRed(f"Error: {exception} in node {ui_sig}")
    return exception

def sort_execution(nodes, xForm_pass):
    execution_failed=False
    sorted_nodes = []
    from .node_common import GraphError
    # check for cycles here by keeping track of the number of times a node has been visited.
    visited={}
    check_max_len=len(nodes)**2 # seems too high but safe. In a well-ordered graph, I guess this number should be less than the number of nodes.
    max_iterations = len(nodes)**2
    i = 0
    while(xForm_pass):
        if execution_failed: break
        if i >= max_iterations:
            execution_failed = True
            raise GraphError("There is probably a cycle somewhere in the graph. "
                                "Or a connection missing in a Group/Schema Input")
        i+=1
        n = xForm_pass.pop()
        if visited.get(n.signature) is not None:
            visited[n.signature]+=1
        else:
            visited[n.signature]=0
        if visited[n.signature] > check_max_len:
            execution_failed = True
            raise GraphError("There is a probably a cycle in the graph somewhere. "
                                "Or a connection missing in a Group/Schema Input")
            # we're trying to solve the halting problem at this point.. don't do that.
            # TODO find a better way! there are algo's for this but they will require using a different solving algo, too
        if n.execution_prepared:
            continue
        if n.node_type not in ['XFORM', 'UTILITY']:
            for dep in n.hierarchy_dependencies:
                if not dep.execution_prepared:
                    xForm_pass.appendleft(n) # hold it
                    break
            else:
                n.execution_prepared=True
                sorted_nodes.append(n)
                for conn in n.hierarchy_connections:
                    if  not conn.execution_prepared:
                        xForm_pass.appendleft(conn)
        else:
            for dep in n.hierarchy_dependencies:
                if not dep.execution_prepared:
                    break
            else:
                n.execution_prepared=True
                sorted_nodes.append(n)
                for conn in n.hierarchy_connections:
                    if  not conn.execution_prepared:
                        xForm_pass.appendleft(conn)
    return sorted_nodes, execution_failed

def execute_tree(nodes, base_tree, context, error_popups = False, profile=False):
    assert nodes is not None, "Failed to parse tree."
    assert len(nodes) > 0, "No parsed nodes for execution."\
                           " Mantis probably failed to parse the tree."
    import bpy
    from time import time
    from .node_common import GraphError
    original_active = context.view_layer.objects.active
    start_execution_time = time()
    mContext = None
    from collections import deque
    xForm_pass = deque()
    for mantis_node in nodes.values():
        if not mContext: # just grab one of these. this is a silly way to do this.
            mContext = mantis_node.mContext
            mContext.b_objects = {} # clear the objects and recreate them
        mantis_node.reset_execution()
        check_and_add_root(mantis_node, xForm_pass)
    mContext.execution_failed = False

    select_me, switch_me = [], [] # switch the mode on these objects
    active = None # only need it for switching modes
    select_me = []
    profiler = None
    if profile:
        from .dev_helpers.profile_nodes import NodeProfiler
        profiler = NodeProfiler()
        profiler.new_session(mContext.execution_id)
        sort_key = 'total'
    try:
        sorted_nodes, execution_failed = sort_execution(nodes, xForm_pass)
        for n in sorted_nodes:
            try:
                if not n.prepared:
                    if profiler: profiler.record(n, "bPrepare", context)
                    else: n.bPrepare(context)
                if not n.executed:
                    if profiler: profiler.record(n, "bTransformPass", context)
                    else: n.bTransformPass(context)
                if (n.__class__.__name__ == "xFormArmature" ):
                    ob = n.bGetObject()
                    switch_me.append(ob)
                    active = ob
                if not (n.__class__.__name__ == "xFormBone" ) and hasattr(n, "bGetObject"):
                    ob = n.bGetObject()
                    if isinstance(ob, bpy.types.Object):
                        select_me.append(ob)
            except Exception as e:
                e = execution_error_cleanup(n, e, show_error=error_popups)
                if error_popups == False:
                    raise e
                execution_failed = True; break

        switch_mode(mode='POSE', objects=switch_me)

        for n in sorted_nodes:
            try:
                if profiler: profiler.record(n, "bPrepare", context)
                else: n.bPrepare(context)
                if not n.executed:
                    if profiler: profiler.record(n, "bRelationshipPass", context)
                    else: n.bRelationshipPass(context)
            except Exception as e:
                e = execution_error_cleanup(n, e, show_error=error_popups)
                if error_popups == False:
                    raise e
                execution_failed = True; break

        switch_mode(mode='OBJECT', objects=switch_me)
        # switch to pose mode here so that the nodes can use the final pose data
        # this will require them to update the depsgraph.

        for ob in switch_me:
            ob.data.pose_position = 'POSE'

        for n in sorted_nodes:
            try:
                if profiler: profiler.record(n, "bFinalize", context)
                else: n.bFinalize(context)
            except Exception as e:
                e = execution_error_cleanup(n, e, show_error=error_popups)
                if error_popups == False:
                    raise e
                execution_failed = True; break

        # REST pose for deformer bind, so everything is in the rest position
        for ob in switch_me:
            ob.data.pose_position = 'REST'

        # finally, apply modifiers and bind stuff
        for n in sorted_nodes:
            try:
                if profiler: profiler.record(n, "bModifierApply", context)
                else: n.bModifierApply(context)
            except Exception as e:
                e = execution_error_cleanup(n, e, show_error=error_popups)
                if error_popups == False:
                    raise e
                execution_failed = True; break

        for ob in switch_me:
            ob.data.pose_position = 'POSE'

        tot_time = (time() - start_execution_time)
        if not execution_failed:
            prGreen(f"Executed tree of {len(sorted_nodes)} nodes in {tot_time} seconds")
        if profiler:
            from .dev_helpers.profile_nodes import summarize_profile
            summarize_profile(profiler._current, pass_name='bPrepare', sort_key = sort_key)
            summarize_profile(profiler._current, pass_name='bTransformPass', sort_key = sort_key)
            summarize_profile(profiler._current, pass_name='bRelationshipPass', sort_key = sort_key)
            summarize_profile(profiler._current, pass_name='bFinalize', sort_key = sort_key)
            summarize_profile(profiler._current, pass_name='bModifierApply', sort_key = sort_key)
        if (original_active):
            context.view_layer.objects.active = original_active
            original_active.select_set(True)
    except Exception as e:
        e = execution_error_cleanup(None, e, switch_me, show_error=error_popups)
        if error_popups == False:
            raise e
        prRed(f"Failed to execute tree.")
    finally:
        context.view_layer.objects.active = active
        # clear the selection first.
        from itertools import chain
        for ob in context.selected_objects:
            try:
                ob.select_set(False)
            except RuntimeError: # it isn't in the view layer
                pass
        for ob in chain(select_me, mContext.b_objects.values()):
            try:
                ob.select_set(True)
            except RuntimeError: # it isn't in the view layer
                pass
